## 날짜: 2025-03-18

### 스크럼

- 학습 목표 1 : CS 면접 준비
- 학습 목표 2 : 인증 필터 구현하기

### 새로 배운 내용

#### 주제 1: 프록시 서버

- 클라이언트와 서버가 통신하는 과정에서 중간에 끼어서 요청과 응답을 중계하고 수정하는 역할을 하는 컴퓨터 시스템이나 응용 프로그램
- Proxy: 서버와 클라이언트 사이의 중계기로써 대리로 통신을 수행하는 것<br>
  Proxy Server: 그 중계 기능을 하는 것
- 기능: 캐싱, 필터링, 로드 밸런싱, 보안, 익명성

  - 캐싱: 자주 요청되는 웹 페이지나 리소스를 캐시에 저장
  - 필터링: 요청과 응답에 대한 필터링 규칙 설정
    특정 웹 사이트나 콘텐츠에 대한 접근 허용 및 차단
  - 로드 밸런싱: 여러 개의 웹 서버로부터 요청을 분산
  - 보안: 방화벽 역할을 화여, 외부로부터 공격 및 침입 방지
  - 익명성: 클라이언트 신원 정보 숨기거나 변경하여 서버에 익명으로 요청

- 리버스 프록시 vs 포워드 프록시<br>
  포워드 프록시: 클라이언트가 원하는 웹 서버에 직접 접근하지 않고 간접적으로 데이터를 주고받는 서버

  - 방화벽, 콘텐츠 필터링, 캐싱 등을 위해 사용

  리버스 프록시: 웹 서버가 클라이언트에 직접 응답하지 않고, 프록시 서버를 통해 간접적으로 데이터를 전달하는 서버

  - 보안, 성능, 안정성을 향상시키기 위해 사용

- VPN과 Proxy Server의 차이점<br>
  VPN은 인터넷 트래픽을 암호화하고 다른 서버를 통해 전송하는 서비스<br>
  - 공통점: 트래픽 재라우팅, 사용자의 개인 정보 숨김<br>
  - 차이점:
    - VPN<br>
      트래픽 암호화를 통해 인터넷 업체와 정부의 감시를 피하고, 해킹 공격 방지 가능<br>
      네트워크(L3), 전송(L4) 수준에서 작동하여 모든 종류의 트래픽 처리 가능<br>
      하지만, 데이터가 암호화되어서 연결 속도는 보다 느릴 수 있음
    - Proxy Server<br>
      응용 프로그램 수준 (L7)에서 작동되어 특정 유형의 요청 및 프록시 연결 설정을 한 소프트웨어에 대해서만 트래픽 재라우팅<br>
      트래픽 암호화하지 않아 보안 취약

#### 주제 2: HTTP

- HTTP란 WWW 상에서 정보를 주고 받기 위한 통신 규약
- 특징: 무상태성, 비연결성, 단순성, 확장성

  - 무상태성: 서버에서 클라이언트의 상태를 저장하지 않으며 각 요청을 독립적으로 처리
  - 비연결성: 서버는 요청에 대한 응답을 보내고 나면 연결을 끊음
  - 단순성: HTTP 메시지는 사람이 읽고 쓸 수 있는 구조와 언어로 되어 있음
  - 확장성: HTTP는 헤더와 바디로 구성된 메시지 형식을 사용하여 다양한 형태의 데이터 전송 가능

- HTTP와 HTTPS의 차이점<br>
  HTTPS는 HTTP에 SSL/TLS라는 보안 계층을 추가한 프로토콜

  1. 보안
     데이터를 암호화하여 전송
  2. 인증
     서버의 신원을 인증하여 클라이언트가 실제로 의도한 서버인지 확인
  3. 성능
     HTTP는 보안 계층이 없기에 보다 빠름

- HTTPS 동작방식

  1. 클라이언트 -> 서버: 서버는 본인의 공개키를 담은 인증서를 보냄
  2. 클라이언트는 인증서 검증하고 서버와 통신할 대칭키 생성
  3. 클라이언트는 서버의 공개키로 대칭키를 암호화하고 서버에 전송
  4. 서버는 비공개키로 대칭키를 복호화하고, 클라이언트와 대칭키를 공유
  5. 클라이언트와 서버는 대칭키로 데이터를 암호화하고 복호화하여 통신

- HTTP 1.1 vs HTTP 2.0<br>
  하나의 TCP 여부에 여러 개의 요청을 처리 할 수 있냐의 차이
  HTTP 1.1은 텍스트 기반으로 헤더 전송
  HTTP 1.1은 클라이언트가 요청한 리소스만 서버가 응답 가능

#### 주제 3: GET, POST, PUT, DELETE

- HTTP 메서드의 일부이며 웹 서버에 요청할 때 사용
- GET: 특정 리소스를 요청하는 메서드
- POST: 서버에게 새로운 리소스를 생성하거나 기존 리소스 수정하라고 요청
- PUT: 특정 리소스를 전체적으로 교체하거나 생성하라고 요청하는 메서드
- DELETE: 특정 리소스를 삭제하라고 요청하는 메서드

GET만 캐시가 가능하고 안전함
POST만 캐시가 가능하고 멱등하지 않음

멱등: 동일한 요청을 여러 번 보내도 서버 상태는 한 번 보낸 것과 같음

#### 주제 4: URI, URL, URN

- 인터넷에서 자원을 식별하는 방식<br>
  URI가 가장 상위 개념
  - URI: 자원을 식별하는 문자열
  - URL: 리소스의 위치를 나타내는 문자열<br>
    schema(http, https), domain name(ww.example.com, 127.0.0.1)<br>
    port(80,443), path(/images), query(?name='sen')<br>
    fragment(#section1) - 일종의 책갈피 역할
  - URN: 자원의 이름을 나타내는 문자열

#### 주제 5: REST API

- 클라이언트와 서버 간의 통신 방식을 정의한 REST라는 아키텍처 스타일을 따르는 웹 API<br>
- 컴포넌트 간의 상호작용을 위한 필수 제약조건

  - 클라이언트-서버 구조
  - 무상태성
  - 캐시 가능성
  - 계층화된 시스템: 중간계층(로드 밸런서, 프록시, 게이트웨이) 존재
  - 균일한 인터페이스: 자원 식별 및 조작 방식이 통일되어 있어 일관성과 단순성 제공
  - 리소스 식별 및 조작 조건: 웹에서 식별 및 접근 가능한 모든 것을 의미하는 각 리소스는 고유한 URI로 식별하면서 리소스 조작 가능
  - 자기 서술적 메시지: 요청과 응답 메시지에 필요한 정보가 모두 포함되어 있어 메시지만으로 수행할 작업 이해 가능
  - HATEOAS: 클라이언트가 현재 리소스와 연관된 다른 리소스에 접근할 수 있는 하이퍼미디어 정보를 제공

- REST API vs RESTful API
  완벽하게 모든 제약조건을 지키는 것이 RESTful API

#### 주제 6: DNS

- IP 주소를 사람이 이해하기 쉬운 도메인 이름으로 변환하고 라우팅 정보를 제공하는 계층형 분산 데이터베이스 시스템

- 기본 동작 방식
  클라이언트가 주소 입력하면,
  1. 사용자 컴퓨터의 DNS 캐시와 hosts 파일 확인
  2. 없다면, 로컬 DNS 서버에게 요청
  3. 없다면 로컬 DNS 서버가 루트 네임 서버에게 반복적 쿼리
  4. 루트 네임 서버가 TLD 네임 서버 반환
  5. 로컬 DNS 서버가 TLD 서버에게 반복적 쿼리
  6. TLD 서버가 하위 도메인 네임 서버 반환
  7. 로컬 DNS 서버가 하위 도메인 서버에게 반복적 쿼리
  8. 하위 도메인 서버가 IP 주소 반환
  9. 로컬 DNS 서버가 캐시에 저장 후 사용자에게 IP 주소 반환

#### 주제 7: TCP vs UDP

- IP가 패킹을 배달하면 TCP, UDP는 이 패킷을 관리하고 통신하는 방법
- TCP는 연결형 프로토콜로 송, 수신자 간 양방향 통신
- UDP는 비연결형 프로토콜로 보다 속도가 빠름

#### 주제 8: SOAP

- XML 형식으로 데이터를 전송하기 위한 프로토콜<br>
  원격 프로시져 호출 패턴을 사용<br>
  장: 플랫폼과 프로그래밍 언어에 대해 독립적, 에러 처리에 대한 기본적인 내용 내장<br>
  단: 복잡한 구조로 오버헤드 발생하여 확장성 좋지 않고, 느리고 무겁고, 개발 난이도 높음

#### 주제 9: 웹 호스팅

- 웹 애플리케이션이 쉽게 작동하는 데 필요나 모든 종류의 파일과 데이터를 저장할 수 있는 물리적 서버의 공간을 임대하는 것

- 공유 호스팅: 여러 사용자가 하나의 서버를 공유하는 방식<br>
  성능과 확장성에 제한
- 가상 사설 서버(VPS): 하나의 물리적 서버에 가상의 여러 서버를 구성<br>
  더 많은 서버 제어 제공
- 전용 서버: 전체 서버를 독점적으로 사용하는 방식
- 클라우드 호스팅: 여러 대의 서버가 연결되어 하나의 클라우드 형성

#### 주제 10: 웹 서버

- 클라이언트로부터 HTTP 요청을 받고, 웹 페이지, 이미지, CSS, JavaScript 파일 등을 제공하는 서버

- WAS: 웹 애플리케이션 서버
  웹 브라우저와 같은 클라이언트와 서버 간의 소통을 원할하게 해주는 미들웨어의 한 종류
  정적 콘텐츠를 전달하는 것이 아닌 DB 연결과 같은 동적 콘텐츠 처리

#### 주제 11: CORS

- 교차 출처 리소스 공유<br>
  다른 출처의 리소스에 접근할 수 있도록 브라우저와 서버가 협력하는 방식

#### 주제 12: XSS

- 공격자가 웹 사이트에 악성 스크립트를 삽입하여 정보 탈취

- 유형
  - Stored XSS(저장형 XSS): 웹 사이트에 악성 스크립트를 영구적으로 저장
  - Reflected XSS(반사형 XSS): URL을 통해 악성 스크립트가 반사되어 실행
  - DOM Based XSS(DOM 기반 XSS): DOM 조작을 하여 악성 스크립트 삽입하여 실행

#### 주제 13: CSRF

- 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행동을 하게 해서 서버에 요청을 보내는 방식<br>
  로그인한 상태에서 발생하며, 사용자의 인증 정보를 이용해 서버에 변조된 요청을 보냄

- 방지법

  - Referer 검증: 백엔드에서 referer 확인하여 domain 일치하는 지 검증
  - CSRF Token 사용: 서버가 생성한 토큰을 포함시켜 서버가 요청이 유효한 지 확인

- XSS와 CSRF 차이<br>
  XSS는 클라이언트 측에서 코드 실행을 통해 정보 탈취<br>
  CSRF는 서버 측에서 이미 인증 받은 상태를 이용하여 원치 않은 동작 수행

### 오늘의 도전 과제와 해결 방법

- 도전 과제 1: 인증 필터 오류 - spring security<br>
  코드 작성을 완료헀는데 자꾸 403에러가 발생<br>
  security dependency 추가하면 에러가 발생한다는 것을 확인<br>
  security쪽 수정<br>

  ```
    http.authorizeHttpRequests(
        (authorizeRequests) -> {
          authorizeRequests.anyRequest().permitAll();
        });

    http.csrf(AbstractHttpConfigurer::disable);
  ```

  추가함 - 해결

### 오늘의 회고

- 오늘의 학습 경험에 대한 자유로운 생각이나 느낀 점을 기록합니다.
- 성공적인 점, 개선해야 할 점, 새롭게 시도하고 싶은 방법 등을 포함할 수 있습니다.

### 참고 자료 및 링크

- [링크 제목](URL)
- [링크 제목](URL)
